import fs from 'fs';
import path from 'path';

const vaultPath = path.join('vault');

const getFiles = (dirPath, arrayOfFiles) => {
    const files = fs.readdirSync(dirPath);

    arrayOfFiles = arrayOfFiles || [];

    files.forEach((file) => {
        if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
            arrayOfFiles = getFiles(`${file}`, arrayOfFiles);
        } else {
            arrayOfFiles.push(path.join(`${file}`));
        }
    });

    return arrayOfFiles;
}

const files = getFiles(vaultPath);

const fileContents = files.map((filePath) => {
    return fs.readFileSync(path.join(vaultPath, filePath), 'utf-8');
});

const processContents = (files, contents) => {
    const base = files.map((file, index) => {
        const [mdAttributes, content] = contents[index].split("===");

        if (!mdAttributes || !content) return null;

        const attributes = mdAttributes
            .split("\n")
            .filter((line) => line !== "")
            .map((line) => line.split(":"))
            .map((line) => line.map((item) => item.trim()))
            .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});

        const filename = file.replace("../../vault/", "").replace(".md", "");

        const description = attributes.description || content
            .slice(0, 140)
            .replace(/[^a-zA-Z0-9 ]/g, "")
            .trim()

        const { title, image } = attributes;

        if (!title || !image) return null;

        return {
            filename,
            title,
            description,
            image,
            content: content.trim(),
            attributes: {
                created: new Date(attributes.created || 0),
                readTime: Math.floor(content.split(" ").length / 200),
                authors: attributes.author?.split(",") || [],
                tags: attributes.tag?.split(","),
                related: attributes.related?.split(","),
            }
        };
    });

    return base
        .map((file) => {
            if (!file) return null;

            const inbound = base
                .filter((item) => item !== null)
                .filter((item) => item.attributes.related?.includes(file.filename))
                .map((item) => item.filename);

            return {
                ...file,
                attributes: {
                    ...file.attributes,
                    inbound
                }
            };
        })
        .sort((a, b) => {
            if (!a || !b) return 0;

            return b.attributes.created.getTime() - a.attributes.created.getTime();
        })
};

const processedContents = processContents(files, fileContents)
    .filter((item) => item !== null);

const generatedCode = `// Do not edit this file directly - ${new Date().toLocaleDateString()}. 

import { PostProps } from "../types"

const directory: PostProps[] = ${JSON.stringify(
    processedContents,
    null,
    4
).replace(/"([^"]+)":/g, '$1:')};

export const usePosts = (): PostProps[] => {
    return directory;
}

export const usePost = (filename: string): PostProps | undefined => {
    return directory.find((post) => post?.filename === filename);
}`;

fs.writeFileSync(path.join("src/hooks/usePost.tsx"), generatedCode);